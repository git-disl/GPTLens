[
    {
        "function_name": "withdraw",
        "vulnerability": "Re-entrancy attack",
        "criticism": "The reasoning is incorrect. The 'transfer' function in Solidity is safe from re-entrancy attacks because it only forwards 2300 gas, which is not enough to perform any state-changing operations. Therefore, an attacker cannot re-enter the function to drain the contract's Ether. However, the function does not check if the contract has enough balance before the transfer, which could lead to a failed transaction.",
        "correctness": 2,
        "severity": 1,
        "profitability": 1,
        "reason": "The 'transfer' function call is not protected against re-entrancy. An attacker can re-enter the function to drain the contract's Ether. The state variables should be updated before the transfer call.",
        "code": "function withdraw() public { require(worldOwner == msg.sender); lottoIndex += 1; numtickets = 0; totalBounty = 0; worldOwner.transfer(this.balance); }",
        "label": "Bad Randomness",
        "file_name": "2018-15552.sol",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "AddTicket",
        "vulnerability": "Denial of service",
        "criticism": "The reasoning is partially correct. If the 'payWinner' function call fails, it could indeed prevent further tickets from being added. However, the function 'payWinner' is private and can only be called within the contract. Therefore, the risk of it failing is low unless there is a bug in the contract code itself. The severity and profitability of this vulnerability are therefore low.",
        "correctness": 6,
        "severity": 3,
        "profitability": 3,
        "reason": "The function does not handle failure of the 'payWinner' function call. If the 'payWinner' function call fails, the contract will be stuck in a state where no further tickets can be added.",
        "code": "function AddTicket() public payable { require(msg.value == ticketPrice); require(numtickets < maxTickets); lastTicketTime = now; numtickets += 1; totalBounty += ticketPrice; bool success = numtickets == maxTickets; NewTicket(msg.sender, success); if(success) { PayWinner(msg.sender); } }",
        "label": "Bad Randomness",
        "file_name": "2018-15552.sol",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    },
    {
        "function_name": "PayWinner",
        "vulnerability": "Integer underflow",
        "criticism": "The reasoning is correct. The function does not check if 'maxTickets' is greater than 0 before subtracting 1, which can lead to integer underflow. This could potentially allow an attacker to buy a large number of tickets for a low price, increasing their chances of winning. The severity and profitability of this vulnerability are high.",
        "correctness": 9,
        "severity": 9,
        "profitability": 9,
        "reason": "This function does not check if 'maxTickets' is greater than 0 before subtracting 1. This can lead to integer underflow, where 'maxTickets' becomes a very large number.",
        "code": "function PayWinner( address winner ) private { require(numtickets == maxTickets); uint ownerTax = 6 * totalBounty / 100; uint winnerPrice = totalBounty - ownerTax; LottoComplete(msg.sender, lottoIndex, winnerPrice); lottoIndex += 1; numtickets = 0; totalBounty = 0; if(_direction == 0 && maxTickets < 20) maxTickets += 1; if(_direction == 1 && maxTickets > 10) maxTickets -= 1; if(_direction == 0 && maxTickets == 20) _direction = 1; if(_direction == 1 && maxTickets == 10) _direction = 0; worldOwner.transfer(ownerTax); winner.transfer(winnerPrice); }",
        "label": "Bad Randomness",
        "file_name": "2018-15552.sol",
        "description": "The \"PayWinner\" function of a simplelottery smart contract implementation for The Ethereum Lottery, an Ethereum gambling game, generates a random value with publicly readable variable \"maxTickets\" (which is private, yet predictable and readable by the eth.getStorageAt function). Therefore, it allows attackers to always win and get rewards."
    }
]