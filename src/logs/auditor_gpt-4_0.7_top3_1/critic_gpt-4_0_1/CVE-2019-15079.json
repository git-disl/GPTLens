[
    {
        "function_name": "_transfer",
        "vulnerability": "Integer Overflow and Underflow",
        "criticism": "The reasoning is partially correct. The function does have checks to prevent both overflow and underflow. The 'require' statement ensures that the '_value' is not larger than 'balanceOf[_from]', preventing underflow. Similarly, the 'require' statement ensures that the sum of 'balanceOf[_to]' and '_value' is not smaller than 'balanceOf[_to]', preventing overflow. However, the function does not check if '_from' and '_to' are the same address, which could lead to unnecessary transfers.",
        "correctness": 5,
        "severity": 3,
        "profitability": 2,
        "reason": "The addition of '_value' to 'balanceOf[_to]' can lead to overflow if the '_value' is very large. This can lead to arbitrary balance manipulation. Similarly, the subtraction of '_value' from 'balanceOf[_from]' can lead to underflow if '_value' is larger than 'balanceOf[_from]'.",
        "code": "function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); }",
        "label": "Typo Constructor",
        "file_name": "2019-15079.sol",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    },
    {
        "function_name": "burn",
        "vulnerability": "Integer Underflow",
        "criticism": "The reasoning is incorrect. The function has a 'require' statement that ensures '_value' is not larger than 'balanceOf[msg.sender]', preventing underflow. However, the function does not check if the 'totalSupply' is less than '_value', which could lead to underflow of 'totalSupply'.",
        "correctness": 3,
        "severity": 6,
        "profitability": 5,
        "reason": "The subtraction of '_value' from 'balanceOf[msg.sender]' can lead to underflow if '_value' is larger than 'balanceOf[msg.sender]'. This can lead to arbitrary balance manipulation.",
        "code": "function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; }",
        "label": "Typo Constructor",
        "file_name": "2019-15079.sol",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    },
    {
        "function_name": "transferFrom",
        "vulnerability": "Reentrancy Attack",
        "criticism": "The reasoning is incorrect. The 'allowance' is updated before the '_transfer' function is called, preventing a reentrancy attack. However, the function does not check if '_from' and '_to' are the same address, which could lead to unnecessary transfers.",
        "correctness": 3,
        "severity": 2,
        "profitability": 1,
        "reason": "The '_transfer' function is called before the 'allowance' is updated. This can potentially lead to reentrancy attack where the attacker can repeatedly call 'transferFrom' before the 'allowance' is updated, draining the contract's funds.",
        "code": "function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; }",
        "label": "Typo Constructor",
        "file_name": "2019-15079.sol",
        "description": "A typo exists in the constructor of a smart contract implementation for EAI through 2019-06-05, an Ethereum token. This vulnerability could be used by an attacker to acquire EAI tokens for free."
    }
]